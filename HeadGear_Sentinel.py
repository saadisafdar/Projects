#!/usr/bin/env python3
"""
HeadGear Sentinel
A single-file Python GUI app for PPE (construction worker) detection:
- Train a YOLOv8 model from scratch on a YOLO-format dataset.
- Run detection on single images (no video/webcam).
- Show safety results per detected person (Helmet, Goggles, Mask, Gloves, Safety Vest, Boots).

Classes (fixed for this project):
0: person
1: helmet
2: goggles
3: mask
4: gloves
5: safety vest
6: boots

Notes:
- This script expects Python 3.8+ and the following packages:
    pip install ultralytics opencv-python pillow pyyaml numpy
  (tkinter is part of the standard library on most Linux distros)
- Training from scratch on CPU will be slow. Defaults are tuned for CPU-light use:
    epochs=30, batch=4, imgsz=640.
- Dataset must be in YOLO format:
    datasets/headgear/images/train, images/val
    datasets/headgear/labels/train, labels/val
  Or edit the data.yaml after you generate it.
- This script creates `data.yaml` and a scratch model yaml (yolov8_headgear_scratch.yaml)
  based on the Ultralytics-provided yolov8n.yaml (so training starts from random init).
- Everything runs from this single file (GUI + training + detection + simple evaluation).

Author: Generated by Copilot on user's request (customized).
"""

import os
import sys
import threading
import queue
import time
import traceback
from pathlib import Path
import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from PIL import Image, ImageTk, ImageDraw, ImageFont
import numpy as np

# Try imports and show friendly message if missing
try:
    from ultralytics import YOLO
except Exception as e:
    print("Missing or broken 'ultralytics' package. Install with: pip install ultralytics")
    raise

try:
    import cv2
except Exception as e:
    print("Missing 'opencv-python'. Install with: pip install opencv-python")
    raise

try:
    import yaml
except Exception as e:
    print("Missing 'pyyaml'. Install with: pip install pyyaml")
    raise

# -----------------------------
# Project constants / defaults
# -----------------------------
PROJECT_ROOT = Path.cwd()
DATA_YAML = PROJECT_ROOT / "data.yaml"
SCRATCH_MODEL_YAML = PROJECT_ROOT / "yolov8_headgear_scratch.yaml"
DEFAULT_MODEL_BASE = "yolov8n.yaml"  # template inside ultralytics package
CLASS_NAMES = {
    0: "person",
    1: "helmet",
    2: "goggles",
    3: "mask",
    4: "gloves",
    5: "safety_vest",
    6: "boots",
}
NC = len(CLASS_NAMES)

# Default training hyperparams tuned for a CPU-light setup
DEFAULT_EPOCHS = 30
DEFAULT_BATCH = 4
DEFAULT_IMGSZ = 640
DEFAULT_DEVICE = "cpu"

# Safety detection thresholds
CENTER_WITHIN_PERSON = True  # primary test: PPE center inside person box
IOU_THRESHOLD = 0.15  # fallback IoU threshold if needed

# -----------------------------
# Utilities
# -----------------------------
def find_ultralytics_model_yaml(name=DEFAULT_MODEL_BASE):
    """
    Try to locate model yaml inside installed ultralytics package.
    Returns Path or raises FileNotFoundError.
    """
    import ultralytics
    base = Path(ultralytics.__file__).parent
    candidates = [
        base / "models" / name,
        base / "yolo" / "models" / name,
        base / name,
        base / "data" / name,
    ]
    for c in candidates:
        if c.exists():
            return c
    # As a last resort, search recursively (slower)
    for p in base.rglob(name):
        return p
    raise FileNotFoundError(f"Could not find {name} inside ultralytics package. Searched common locations.")

def make_scratch_model_yaml(out_path=SCRATCH_MODEL_YAML, base_name=DEFAULT_MODEL_BASE):
    """
    Read base yolov8 model yaml (from ultralytics) and write a copy with updated nc and names.
    """
    try:
        src = find_ultralytics_model_yaml(base_name)
    except FileNotFoundError as e:
        raise

    cfg = yaml.safe_load(src.read_text())

    # Set number of classes and names mapping
    cfg['nc'] = NC
    # YOLO model YAML expects 'names' as list or mapping; we write mapping for clarity
    names_map = {i: CLASS_NAMES[i] for i in range(NC)}
    cfg['names'] = names_map

    out_path.write_text(yaml.dump(cfg, sort_keys=False))
    return out_path

def write_data_yaml(train_dir, val_dir, out_path=DATA_YAML):
    """
    Create data.yaml pointing to provided train/val image folders and names.
    """
    data = {
        "train": str(Path(train_dir).resolve()),
        "val": str(Path(val_dir).resolve()),
        "names": {i: CLASS_NAMES[i] for i in range(NC)}
    }
    out_path.write_text(yaml.dump(data, sort_keys=False))
    return out_path

def box_center(box):
    # box is [x1, y1, x2, y2]
    x1, y1, x2, y2 = box
    return ((x1 + x2) / 2.0, (y1 + y2) / 2.0)

def center_in_box(cx, cy, box):
    x1, y1, x2, y2 = box
    return (cx >= x1) and (cx <= x2) and (cy >= y1) and (cy <= y2)

def iou(a, b):
    # a, b are [x1,y1,x2,y2]
    ax1, ay1, ax2, ay2 = a
    bx1, by1, bx2, by2 = b
    inter_x1 = max(ax1, bx1)
    inter_y1 = max(ay1, by1)
    inter_x2 = min(ax2, bx2)
    inter_y2 = min(ay2, by2)
    iw = max(0.0, inter_x2 - inter_x1)
    ih = max(0.0, inter_y2 - inter_y1)
    inter = iw * ih
    area_a = max(0.0, ax2 - ax1) * max(0.0, ay2 - ay1)
    area_b = max(0.0, bx2 - bx1) * max(0.0, by2 - by1)
    union = area_a + area_b - inter
    if union == 0:
        return 0.0
    return inter / union

# -----------------------------
# GUI Thread-safe logging helper
# -----------------------------
class GuiLogger:
    def __init__(self, text_widget):
        self.text = text_widget
        self.queue = queue.Queue()
        self._running = True
        self._poll()

    def write(self, s):
        # Called by training code (redirected stdout)
        self.queue.put(s)

    def flush(self):
        pass

    def _poll(self):
        try:
            while True:
                s = self.queue.get_nowait()
                # Append to text widget
                self.text.configure(state="normal")
                self.text.insert("end", s)
                self.text.see("end")
                self.text.configure(state="disabled")
        except queue.Empty:
            pass
        if self._running:
            self.text.after(200, self._poll)

    def stop(self):
        self._running = False

# -----------------------------
# Safety evaluation logic
# -----------------------------
def evaluate_safety(detections):
    """
    detections: list of dicts each with keys: cls (int), box (x1,y1,x2,y2), score
    Returns:
      - annotated list per person: {person_id, person_box, present: {class_name: bool}, missing: [class_names], overall_ok: bool}
      - summary: percent_compliant, counts
    """
    # Separate persons and ppe
    persons = []
    ppes = []
    for d in detections:
        if d['cls'] == 0:
            persons.append(d)
        else:
            ppes.append(d)

    results = []
    for pid, person in enumerate(persons, start=1):
        pbox = person['box']
        present = {}
        for cls_id in range(1, NC):
            present[CLASS_NAMES[cls_id]] = False

        # For each ppe, test center-in-person or IoU with person
        for p in ppes:
            cls_id = p['cls']
            cbx, cby = box_center(p['box'])
            inside = center_in_box(cbx, cby, pbox)
            overlap = iou(p['box'], pbox)
            if inside or overlap >= IOU_THRESHOLD:
                present[CLASS_NAMES[cls_id]] = True

        missing = [k for k, v in present.items() if not v]
        overall_ok = (len(missing) == 0)
        results.append({
            "person_id": pid,
            "person_box": pbox,
            "present": present,
            "missing": missing,
            "overall_ok": overall_ok,
            "person_score": float(person.get('score', 0.0))
        })
    # Summary: percent persons fully compliant
    if len(results) == 0:
        percent = 0.0
    else:
        percent = sum(1 for r in results if r['overall_ok']) / len(results) * 100.0
    summary = {
        "total_persons": len(results),
        "compliant_persons": sum(1 for r in results if r['overall_ok']),
        "percent_compliant": percent
    }
    return results, summary

# -----------------------------
# Main Application (Tkinter)
# -----------------------------
class HeadGearSentinelApp:
    def __init__(self, root):
        self.root = root
        self.root.title("HeadGear Sentinel - PPE Detection (single-file)")
        self.root.geometry("1100x720")
        self.model = None
        self.weights_path = None  # path to best.pt after training or loaded
        self.current_image = None
        self.annotated_image = None

        # UI layout frames
        self.left_frame = ttk.Frame(root, width=360)
        self.left_frame.pack(side="left", fill="y", padx=8, pady=8)
        self.right_frame = ttk.Frame(root)
        self.right_frame.pack(side="right", expand=True, fill="both", padx=8, pady=8)

        self._build_left_panel()
        self._build_right_panel()

        # Logger text area
        self.logger = GuiLogger(self.log_text)

    def _build_left_panel(self):
        frm = self.left_frame

        title = ttk.Label(frm, text="HeadGear Sentinel", font=("Segoe UI", 14, "bold"))
        title.pack(pady=(4, 10))

        # Dataset section
        ds_label = ttk.Label(frm, text="Dataset (YOLO format)", font=("Segoe UI", 10, "bold"))
        ds_label.pack(anchor="w", pady=(6, 0))

        self.train_dir_var = tk.StringVar(value=str(PROJECT_ROOT / "datasets" / "headgear" / "images" / "train"))
        self.val_dir_var = tk.StringVar(value=str(PROJECT_ROOT / "datasets" / "headgear" / "images" / "val"))

        train_frame = ttk.Frame(frm)
        train_frame.pack(fill="x", pady=3)
        ttk.Label(train_frame, text="Train:").grid(row=0, column=0, sticky="w")
        ttk.Entry(train_frame, textvariable=self.train_dir_var, width=40).grid(row=0, column=1, padx=4)
        ttk.Button(train_frame, text="Browse", command=self.browse_train_dir).grid(row=0, column=2, padx=2)

        val_frame = ttk.Frame(frm)
        val_frame.pack(fill="x", pady=3)
        ttk.Label(val_frame, text="Val:  ").grid(row=0, column=0, sticky="w")
        ttk.Entry(val_frame, textvariable=self.val_dir_var, width=40).grid(row=0, column=1, padx=4)
        ttk.Button(val_frame, text="Browse", command=self.browse_val_dir).grid(row=0, column=2, padx=2)

        ttk.Button(frm, text="Generate data.yaml", command=self.cmd_generate_data_yaml).pack(fill="x", pady=6)

        # Model section
        model_label = ttk.Label(frm, text="Model / Training", font=("Segoe UI", 10, "bold"))
        model_label.pack(anchor="w", pady=(8, 0))

        self.epochs_var = tk.IntVar(value=DEFAULT_EPOCHS)
        self.batch_var = tk.IntVar(value=DEFAULT_BATCH)
        self.imgsz_var = tk.IntVar(value=DEFAULT_IMGSZ)

        hp_frame = ttk.Frame(frm)
        hp_frame.pack(fill="x", pady=3)
        ttk.Label(hp_frame, text="Epochs:").grid(row=0, column=0, sticky="w")
        ttk.Entry(hp_frame, textvariable=self.epochs_var, width=6).grid(row=0, column=1, padx=4)
        ttk.Label(hp_frame, text="Batch:").grid(row=0, column=2, sticky="w")
        ttk.Entry(hp_frame, textvariable=self.batch_var, width=6).grid(row=0, column=3, padx=4)

        imgsz_frame = ttk.Frame(frm)
        imgsz_frame.pack(fill="x", pady=3)
        ttk.Label(imgsz_frame, text="Image size:").grid(row=0, column=0, sticky="w")
        ttk.Entry(imgsz_frame, textvariable=self.imgsz_var, width=8).grid(row=0, column=1, padx=4)
        ttk.Label(imgsz_frame, text="Device: cpu only").grid(row=0, column=2, padx=6)

        ttk.Button(frm, text="Prepare scratch model YAML", command=self.cmd_prepare_scratch_yaml).pack(fill="x", pady=6)
        ttk.Button(frm, text="Train from scratch (runs on CPU)", command=self.cmd_train_threaded).pack(fill="x", pady=6)

        ttk.Separator(frm, orient="horizontal").pack(fill="x", pady=8)

        ttk.Button(frm, text="Load weights (.pt)", command=self.cmd_load_weights).pack(fill="x", pady=6)
        ttk.Button(frm, text="Export model to ONNX (after training)", command=self.cmd_export_onnx).pack(fill="x", pady=6)

        ttk.Separator(frm, orient="horizontal").pack(fill="x", pady=8)

        ttk.Label(frm, text="Detection (images only)", font=("Segoe UI", 10, "bold")).pack(anchor="w", pady=(4, 0))
        ttk.Button(frm, text="Open Image...", command=self.cmd_open_image).pack(fill="x", pady=4)
        ttk.Button(frm, text="Run Detection", command=self.cmd_detect).pack(fill="x", pady=4)
        ttk.Button(frm, text="Evaluate Safety (on last detection)", command=self.cmd_evaluate_safety).pack(fill="x", pady=4)

        ttk.Separator(frm, orient="horizontal").pack(fill="x", pady=8)

        ttk.Label(frm, text="Console / Logs", font=("Segoe UI", 10, "bold")).pack(anchor="w", pady=(2, 0))
        self.log_text = tk.Text(frm, height=12, state="disabled", wrap="word")
        self.log_text.pack(fill="both", expand=True)

    def _build_right_panel(self):
        frm = self.right_frame
        # Top: image canvas
        self.canvas = tk.Canvas(frm, bg="#222222")
        self.canvas.pack(fill="both", expand=True)

        # Bottom: results area
        bottom = ttk.Frame(frm)
        bottom.pack(fill="x")
        self.results_text = tk.Text(bottom, height=12, state="disabled", wrap="word")
        self.results_text.pack(fill="both", expand=True)

    # -------------------------
    # Left panel command methods
    # -------------------------
    def browse_train_dir(self):
        d = filedialog.askdirectory(title="Select train images directory (images/train)")
        if d:
            self.train_dir_var.set(d)

    def browse_val_dir(self):
        d = filedialog.askdirectory(title="Select val images directory (images/val)")
        if d:
            self.val_dir_var.set(d)

    def cmd_generate_data_yaml(self):
        train = self.train_dir_var.get().strip()
        val = self.val_dir_var.get().strip()
        if not train or not val:
            messagebox.showwarning("Missing paths", "Please set both train and val directories.")
            return
        try:
            out = write_data_yaml(train, val, DATA_YAML)
            self._log(f"Generated data.yaml at: {out}\nContent:\n{out.read_text()}\n")
            messagebox.showinfo("data.yaml", f"Created {out}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to write data.yaml: {e}\n{traceback.format_exc()}")

    def cmd_prepare_scratch_yaml(self):
        try:
            out = make_scratch_model_yaml()
            self._log(f"Created scratch model yaml: {out}\n")
            messagebox.showinfo("Model YAML", f"Created {out}")
        except Exception as e:
            messagebox.showerror("Error", f"Could not create scratch model yaml: {e}\n{traceback.format_exc()}")

    def cmd_load_weights(self):
        p = filedialog.askopenfilename(title="Select .pt weights file", filetypes=[("PyTorch weights", "*.pt"), ("All files","*.*")])
        if not p:
            return
        self.weights_path = Path(p)
        self._log(f"Loaded weights: {self.weights_path}\n")
        # instantiate model for inference
        try:
            self.model = YOLO(str(self.weights_path))
            self._log("Model loaded for inference.\n")
            messagebox.showinfo("Weights", f"Loaded model weights for inference: {self.weights_path}")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to load model: {e}\n{traceback.format_exc()}")

    def cmd_export_onnx(self):
        if not self.weights_path or not Path(self.weights_path).exists():
            messagebox.showwarning("No weights", "No trained weights available. Train or load weights first.")
            return
        try:
            out_dir = PROJECT_ROOT / "exported"
            out_dir.mkdir(exist_ok=True)
            self._log("Exporting to ONNX (this may take a while)...\n")
            # Use ultralytics CLI-style export via Python API
            # This will create files under 'exported' relative to run, but YOLO.export returns a path list
            model = YOLO(str(self.weights_path))
            res = model.export(format="onnx")
            self._log(f"Export result: {res}\n")
            messagebox.showinfo("Export", f"Exported ONNX. See console log for details.")
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export ONNX: {e}\n{traceback.format_exc()}")

    # Training (threaded)
    def cmd_train_threaded(self):
        # Validate paths
        if not DATA_YAML.exists():
            messagebox.showwarning("Missing data.yaml", "Please generate data.yaml first (pointing to your dataset).")
            return
        if not SCRATCH_MODEL_YAML.exists():
            messagebox.showwarning("Missing model yaml", "Please prepare scratch model YAML first.")
            return
        # disable interactive buttons while training
        t = threading.Thread(target=self._train, daemon=True)
        t.start()

    def _train(self):
        try:
            # redirect ultralytics prints to GUI log
            orig_stdout = sys.stdout
            orig_stderr = sys.stderr
            sys.stdout = self.logger
            sys.stderr = self.logger

            epochs = int(self.epochs_var.get())
            batch = int(self.batch_var.get())
            imgsz = int(self.imgsz_var.get())

            self._log(f"Starting training from scratch using {SCRATCH_MODEL_YAML}\n")
            # Using YOLO Python API to train from yaml -> this starts from random if model is yaml
            y = YOLO(str(SCRATCH_MODEL_YAML))
            # Train - device forced to cpu in this app (user's machine)
            y.train(data=str(DATA_YAML), epochs=epochs, imgsz=imgsz, batch=batch, device=DEFAULT_DEVICE)
            # After training, ultralytics saves weights under runs/detect/train/weights/best.pt (or similar)
            # Find latest runs/detect/*/weights/best.pt
            best = None
            runs_detect = PROJECT_ROOT / "runs" / "detect"
            if runs_detect.exists():
                # iterate newest folder
                subdirs = sorted([d for d in runs_detect.iterdir() if d.is_dir()], key=lambda p: p.stat().st_mtime, reverse=True)
                if subdirs:
                    latest = subdirs[0]
                    cand = latest / "weights" / "best.pt"
                    if cand.exists():
                        best = cand
            if best:
                self.weights_path = best
                self._log(f"\nTraining finished. Best weights at: {best}\n")
                # load for inference
                try:
                    self.model = YOLO(str(self.weights_path))
                    self._log("Loaded trained weights for inference.\n")
                except Exception as e:
                    self._log(f"Warning: failed to load trained weights for inference: {e}\n")
            else:
                self._log("Training finished but best.pt not found automatically. Check runs/detect/*/weights/\n")

        except Exception as e:
            self._log(f"Training error: {e}\n{traceback.format_exc()}\n")
            messagebox.showerror("Training Error", f"{e}\nSee logs for details.")
        finally:
            sys.stdout = orig_stdout
            sys.stderr = orig_stderr

    # -------------------------
    # Detection & Evaluation
    # -------------------------
    def cmd_open_image(self):
        p = filedialog.askopenfilename(title="Open image", filetypes=[("Images", "*.jpg *.jpeg *.png *.bmp"), ("All","*.*")])
        if not p:
            return
        try:
            img = Image.open(p).convert("RGB")
            self.current_image = img.copy()
            self.annotated_image = None
            self._display_image(img)
            self._log(f"Opened image: {p}\n")
        except Exception as e:
            messagebox.showerror("Open Image", f"Failed to open image: {e}")

    def cmd_detect(self):
        if self.current_image is None:
            messagebox.showwarning("No image", "Please open an image first.")
            return
        if self.model is None:
            messagebox.showwarning("No model", "No model loaded. Train a model or load weights (.pt) first.")
            return

        # Run detection in background to keep UI responsive
        t = threading.Thread(target=self._run_detection, daemon=True)
        t.start()

    def _run_detection(self):
        try:
            self._log("Running detection...\n")
            # Convert PIL image to numpy BGR for ultralytics
            img_arr = np.array(self.current_image)
            # ultralytics accepts numpy RGB arrays as source
            results = self.model.predict(source=img_arr, imgsz=int(self.imgsz_var.get()), device=DEFAULT_DEVICE, conf=0.25, verbose=False)
            if not results:
                self._log("No results returned by model.\n")
                return
            r = results[0]
            # boxes: r.boxes.data: Tensor Nx6: x1,y1,x2,y2,conf,cls
            detections = []
            for box in r.boxes.data.tolist():
                x1, y1, x2, y2, conf, cls = box
                detections.append({"cls": int(cls), "box": [float(x1), float(y1), float(x2), float(y2)], "score": float(conf)})

            # annotate image using result's plot if available
            try:
                annotated = r.plot()
                # r.plot returns np array (BGR in many cases) or PIL; ensure PIL RGB
                if isinstance(annotated, np.ndarray):
                    if annotated.dtype == np.uint8:
                        # r.plot returns RGB array usually; confirm
                        ann = Image.fromarray(annotated)
                    else:
                        ann = Image.fromarray((annotated * 255).astype(np.uint8))
                else:
                    ann = Image.fromarray(np.array(annotated))
                self.annotated_image = ann
                self._display_image(ann)
            except Exception as e:
                self._log(f"Could not create annotated image: {e}\n")

            # store last detections for evaluation
            self.last_detections = detections
            self._log(f"Detections: {detections}\n")
            self._log("Detection finished.\n")
        except Exception as e:
            self._log(f"Detection error: {e}\n{traceback.format_exc()}\n")
            messagebox.showerror("Detection Error", f"{e}\nSee logs for details.")

    def cmd_evaluate_safety(self):
        if not hasattr(self, "last_detections") or self.last_detections is None:
            messagebox.showwarning("No detection", "Run detection on an image first.")
            return
        try:
            results, summary = evaluate_safety(self.last_detections)
            # Display results in results_text widget and overlay annotations on image (green/red boxes)
            self._display_evaluation(results, summary)
        except Exception as e:
            self._log(f"Evaluation error: {e}\n{traceback.format_exc()}\n")
            messagebox.showerror("Evaluation Error", f"{e}\nSee logs for details.")

    # -------------------------
    # UI helpers
    # -------------------------
    def _display_image(self, pil_image):
        # Resize image to fit canvas while preserving aspect ratio
        w, h = pil_image.size
        canvas_w = max(400, self.canvas.winfo_width() or 800)
        canvas_h = max(300, self.canvas.winfo_height() or 500)
        scale = min(canvas_w / w, canvas_h / h, 1.0)
        nw, nh = int(w * scale), int(h * scale)
        img_resized = pil_image.resize((nw, nh), Image.ANTIALIAS)
        self.tkimg = ImageTk.PhotoImage(img_resized)
        self.canvas.delete("all")
        self.canvas.create_image(canvas_w//2, canvas_h//2, image=self.tkimg, anchor="center")
        # store for possible overlays later
        self.display_image_for_canvas = img_resized
        self.display_scale = scale

    def _display_evaluation(self, results, summary):
        # Show textual summary
        self.results_text.configure(state="normal")
        self.results_text.delete("1.0", "end")
        self.results_text.insert("end", f"Total persons detected: {summary['total_persons']}\n")
        self.results_text.insert("end", f"Compliant persons: {summary['compliant_persons']} ({summary['percent_compliant']:.1f}%)\n\n")
        for r in results:
            self.results_text.insert("end", f"Person {r['person_id']}: score={r['person_score']:.2f}\n")
            for k, v in r['present'].items():
                self.results_text.insert("end", f"  {k}: {'OK' if v else 'MISSING'}\n")
            self.results_text.insert("end", "\n")
        self.results_text.configure(state="disabled")

        # Overlay colored boxes: green for person OK, red if missing PPE. Also draw PPE boxes with labels.
        if self.annotated_image is None and self.current_image is not None:
            base = self.current_image.copy()
        elif self.annotated_image is not None:
            base = self.annotated_image.copy()
        else:
            return

        draw = ImageDraw.Draw(base)
        # Try to use a truetype font if available
        try:
            font = ImageFont.truetype("DejaVuSans.ttf", 14)
        except Exception:
            font = ImageFont.load_default()

        # Draw persons boxes and PPE boxes
        # First, draw PPE boxes in blue with labels
        for d in getattr(self, "last_detections", []):
            cls_id = d['cls']
            box = d['box']
            label = CLASS_NAMES.get(cls_id, str(cls_id))
            color = (50, 120, 255) if cls_id != 0 else (50, 255, 100)
            x1, y1, x2, y2 = map(int, box)
            draw.rectangle([x1, y1, x2, y2], outline=color, width=3)
            draw.text((x1+4, y1+2), f"{label} {d['score']:.2f}", fill=color, font=font)

        # Now draw person boxes with green/red depending on compliance
        for r in results:
            pbox = r['person_box']
            ok = r['overall_ok']
            color = (0, 200, 0) if ok else (220, 40, 40)
            x1, y1, x2, y2 = map(int, pbox)
            draw.rectangle([x1, y1, x2, y2], outline=color, width=5)
            text = "COMPLIANT" if ok else f"MISSING: {', '.join(r['missing'])}"
            draw.text((x1+4, y2+4), text, fill=color, font=font)

        self.annotated_image = base
        self._display_image(self.annotated_image)

    def _log(self, s):
        # append to log text widget (thread-safe via logger.queue)
        self.logger.write(s)

# -----------------------------
# Main entrypoint
# -----------------------------
def main():
    root = tk.Tk()
    app = HeadGearSentinelApp(root)
    root.protocol("WM_DELETE_WINDOW", lambda: (app.logger.stop(), root.destroy()))
    root.mainloop()

if __name__ == "__main__":
    main()